%% Modified Damped Newtons Method 
% This function will be used to perform the Modified Damped Newtons Method

% Inputs
%   - SV_0: vector, Initial solution vector guess
%   - MESH: struct, Contains mesh properties
% Outputs
%   - SV:   vector, Final solution vector
%   - MESH: struct, Contains mesh properties
%   - SIM:  struct, Contains solution process properties

% Procedure %%%%%%Fix this
% - Find new SV^(n+1)
%   - Look ahead to accept or deny SV^(n+1)
% - Check if Delta SV meets tolerance
% - Check if mesh needs to be refined
        
function [SV, MESH, SIM] = Modified_Damped_Newtons_Method(SV_0, MESH, SIM, BC, TOL, FLAG)
%% Initialize Algorithm
found_soln = false;

num_Jacobian = 0;
SV_current = SV_0;
num_iterations = 0;
%% Start Iterations
while ~found_soln
    num_iterations = num_iterations + 1;
    %% Solve for the correction vector
    % deltaSV^m = J(SV^m)^-1 F(SV^m)
    
    % Calculate the Jacobian
    
    if num_iterations == 1
        % Calculate Jacobian
        Jac = Jacobian(SV_current, MESH, SIM, BC, TOL);
    end
    
    if num_Jacobian < 20
        % Keep current Jacobian
    else 
        % Calculate a new Jacobian
        Jac = Jacobian(SV_current, MESH, SIM, BC, TOL);
        num_Jacobian = 0;
    end
    % Calculate F(SV) <-- F() = Res()
    F_current = BVP_residual(SV_current, MESH, SIM, BC, TOL);
    
    % Calculate correction vector
    del_SV_current = Jac\F_current;
    
    
    %% Solve for the next iteration
    % SV^m+1 = SV^m - lambda^m * deltaSV^m
    
    lambda = 1; %%%%maybe user can add restriction to this in input file
    SV_next = 0;
    del_SV_next = 0;
    found_SV_next = false;
    while ~found_SV_next
        %% Calculate SV^m+1
        SV_temp = SV_current - lambda * del_SV_current;
        
        %% Check if lambda meets tol
        %%%%%%%%%%%% 1) Not checking if in soln space right now
        
        %  2) Check Look ahead criteria
        %  - Calculate deltaSV^m+1
        F_temp = BVP_residual(SV_temp, MESH, SIM, BC, TOL);
        del_SV_temp = Jac\F_temp;
        
        norm_is_smaller = ( norm(del_SV_temp) < norm(del_SV_current) );
        if norm_is_smaller
            % SV^m = SV^m+1
            SV_next = SV_temp;
            del_SV_next = del_SV_temp;
            found_SV_next = true;
        else
            % Try halving lambda
            lambda = lambda * 0.5;
        end
    end
    found_SV_next = false;
    
    %% Check if the new SV meets the iteration tolerances
    within_tol = ( norm(del_SV_next) < max( TOL.A, TOL.R*norm(SV_next) ) );
    
    if within_tol
        % Solution is found
        found_soln = true;
        SV = SV_next;
    else
        % Start another iteration with the new SV
        SV_current = SV_next;
        num_Jacobian = num_Jacobian + 1;
    end
end

%%
% Mesh_Refined = false;
% MDNM_Within_Tol = false;
% New_SV_Accepted = false;
%
% mesh_refine_counter = 0; %%%%%Used for troubleshooting
%
% while ~Mesh_Refined % while loop runs until the condition is false
%     mesh_refine_counter = mesh_refine_counter + 1; %%%%%Used for troubleshooting
%
%     MDNM_iterations = 0;%%%%%Used for troubleshooting
%     while ~MDNM_Within_Tol
%         %% Find the new SV
%         MDNM_iterations = MDNM_iterations + 1;%%%%%Used for troubleshooting
%         lambda = 1;
%         counter = 0;
%         SV_new = SV_current - lambda*deltaSV; %%%%Need deltaSV
%         while ~New_SV_Accepted
%             counter = counter + 1;%%%%%Used for troubleshooting
%             lambda = lambda/2;
%             if counter == 5
%                 New_SV_Accepted = true;
%             end
%         end
%         if MDNM_iterations == 3
%             MDNM_Within_Tol = true;
%         end
%         New_SV_Accepted = false;
%     end
%     MDNM_Within_Tol = false;
%     if mesh_refine_counter == 10
%         Mesh_Refined = true;
%     end
% end
%
% SV = 42;
end